/* -*-c++-*- */
/* osgEarth - Geospatial SDK for OpenSceneGraph
* Copyright 2019 Pelican Mapping
* http://osgearth.org
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/
#ifndef OSGEARTH_SCREEN_SPACE_LAYOUT_H
#define OSGEARTH_SCREEN_SPACE_LAYOUT_H 1

#include <osgEarth/Common>
#include <osgEarth/Config>
#include <osg/Drawable>
#include <osgUtil/RenderLeaf>
#include <limits.h>

#define OSGEARTH_SCREEN_SPACE_LAYOUT_BIN "osgearth_ScreenSpaceLayoutBin"

namespace osgEarth
{
/**
     * Interface that exposes layout information.
     */
class ScreenSpaceLayoutData : public osg::Referenced
{
public:
    /** Install and return a LayoutData on a drawable. */
    static ScreenSpaceLayoutData* getOrCreate(osg::Drawable* drawable)
    {
        if (!drawable) return 0L;
        ScreenSpaceLayoutData* ld = dynamic_cast<ScreenSpaceLayoutData*>(drawable->getUserData());
        if (!ld)
        {
            ld = new ScreenSpaceLayoutData();
            drawable->setUserData(ld);
        }
        return ld;
    }

    /** Constructor */
    ScreenSpaceLayoutData() :
                              _priority(0.f),
                              _originalPriority(0.f),
                              _pixelOffset(0, 0),
                              _autoRotate(false),
                              _autoFollowLine(false),
                              _id(-1) { }

    /** Decluttering priority - FLT_MAX means don't declutter */
    void setPriority(float value) { _originalPriority = _priority = value; }
    float getPriority() const     { return _priority; }

    /** Offset from geoposition in screen pixels */
    void setPixelOffset(const osg::Vec2s& value) { _pixelOffset = value; }
    const osg::Vec2s& getPixelOffset() const     { return _pixelOffset; }

    /** Wether the label shall follow a given geographic course */
    void setAutoRotate(bool autoRotate) { _autoRotate = autoRotate; }
    bool isAutoRotate() const { return _autoRotate; }

    /** World point for label rotation reference */
    void setAnchorPoint(const osg::Vec3d& value) { _anchorPoint = value; }
    const osg::Vec3d& getAnchorPoint() const { return _anchorPoint; }

    /** Wether the label shall automatically replace itself along a line */
    void setAutoFollowLine(bool autoFollowLine) { _autoFollowLine = autoFollowLine; }
    bool isAutoFollowLine() const { return _autoFollowLine; }

    /** Start world point for automatic placement on a line */
    void setLineStartPoint(const osg::Vec3d& value) { _lineStart = value; }
    const osg::Vec3d& getLineStartPoint() const { return _lineStart; }

    /**
     * Stop world point for automatic placement on a line
     * also used as projection point for label rotation reference
     */
    void setLineEndPoint(const osg::Vec3d& value) { _lineEnd = value; }
    const osg::Vec3d& getLineEndPoint() const { return _lineEnd; }

    /** Identifier to group drawables that relates to the same feature */
    void setId(long id) { _id = id; }
    long getId() const { return _id; }

    /** The global BBox for the whole feature (containing all the drawables) */
    const osg::BoundingBox& getBBox() const { return _bbox; }
    void expandBboxBy ( const osg::BoundingBox& bbox) { _bbox.expandBy(bbox); _bsphere.expandRadiusBy(bbox); _bboxSymetric.expandBy(_bsphere); }
    const osg::BoundingBox& getBBoxSymetric() const { return _bboxSymetric; }

public:
    float      _originalPriority;
    float      _priority;
    osg::Vec2s _pixelOffset;
    bool       _autoRotate, _autoFollowLine;
    osg::Vec3d _anchorPoint, _lineStart, _lineEnd;
    long       _id;
    osg::BoundingBox _bbox;
    osg::BoundingSphere _bsphere{osg::Vec3d(0., 0., 0), 0.};
    osg::BoundingBox _bboxSymetric;
    bool        _simpleCharacterInvert {false};

    osg::Vec3d          _cull_anchorOnScreen;
    double              _cull_rotationRadOnScreen;
    osg::BoundingBoxd   _cull_bboxSymOnScreen;

public:
    virtual ~ScreenSpaceLayoutData() { }
};

/**
     * Custom functor that compares two RenderLeaf's and returns TRUE if the left-hand one
     * is higher priority, otherwise FALSE. You can call setDeclutterPriorityFunctor()
     * to set a custom priority-sorting functor.
     */
struct DeclutterSortFunctor : public osg::Referenced
{
    virtual bool operator() ( const osgUtil::RenderLeaf* lhs, const osgUtil::RenderLeaf* rhs ) const =0;
    virtual ~DeclutterSortFunctor() { }
};

/**
     * Options to control the annotation decluttering engine.
     */
class OSGEARTH_EXPORT ScreenSpaceLayoutOptions : public ConfigOptions
{
public:
    ScreenSpaceLayoutOptions( const ConfigOptions& co =ConfigOptions() )
        : ConfigOptions         ( co ),
          _minAnimAlpha         ( 0.35f ),
          _minAnimScale         ( 0.45f ),
          _inAnimTime           ( 0.40f ),
          _outAnimTime          ( 0.00f ),
          _sortByPriority       ( false ),
          _sortByDistance       ( true ),
          _snapToPixel          ( false ),
          _maxObjects           ( INT_MAX ),
          _renderBinNumber      ( 13 ),
          _useScreenGrid        ( false ),
          _screenGridNbCol      ( 28 ),
          _screenGridNbRow      ( 20 )
    {
        fromConfig(_conf);
    }

    virtual ~ScreenSpaceLayoutOptions() { }

    /** Alpha value of a fully-occluded object */
    optional<float>& minAnimationAlpha() { return _minAnimAlpha; }
    const optional<float>& minAnimationAlpha() const { return _minAnimAlpha; }

    /** Scale factor of a fully-occluded object */
    optional<float>& minAnimationScale() { return _minAnimScale; }
    const optional<float>& minAnimationScale() const { return _minAnimScale; }

    /** Time (in seconds) for an object to transition from occluded to visible */
    optional<float>& inAnimationTime() { return _inAnimTime; }
    const optional<float>& inAnimationTime() const { return _inAnimTime; }

    /** Time (in seconds) for an object to transition from visible to occluded */
    optional<float>& outAnimationTime() { return _outAnimTime; }
    const optional<float>& outAnimationTime() const { return _outAnimTime; }

    /** If set, activate the ScreenSpaceLayoutData priority-based sorting */
    optional<bool>& sortByPriority() { return _sortByPriority; }
    const optional<bool>& sortByPriority() const { return _sortByPriority; }

    /** If set, activate the ScreenSpaceLayoutData distance-based sorting */
    optional<bool>& sortByDistance() { return _sortByDistance; }
    const optional<bool>& sortByDistance() const { return _sortByDistance; }

    /** Whether to always start rendering text on a pixel boundary, thereby
      * minimizing filtering artifacts. */
    optional<bool>& snapToPixel() { return _snapToPixel; }
    const optional<bool>& snapToPixel() const { return _snapToPixel; }

    /** Maximum number of objects to draw after sorting */
    optional<unsigned>& maxObjects() { return _maxObjects; }
    const optional<unsigned>& maxObjects() const { return _maxObjects; }

    /** Render bin number to use for the screen layout */
    optional<int>& renderOrder() { return _renderBinNumber; }
    const optional<int>& renderOrder() const { return _renderBinNumber; }

    /** Whether the declutter algorithm uses a screen grid to group annotations
     * according to their location */
    optional<bool>& useScreenGrid() { return _useScreenGrid; }
    const optional<bool>& useScreenGrid() const { return _useScreenGrid; }

    /** The number of columns when screen grid is activated for decluttering */
    optional<int>& screenGridNbCol() { return _screenGridNbCol; }
    const optional<int>& screenGridNbCol() const { return _screenGridNbCol; }

    /** The number of row when screen grid is activated for decluttering */
    optional<int>& screenGridNbRow() { return _screenGridNbRow; }
    const optional<int>& screenGridNbRow() const { return _screenGridNbRow; }

    /** Name of the default font. */
    optional<std::string>& defaultFont() { return _defaultFont; }
    const optional<std::string>& defaultFont() const { return _defaultFont; }

    /** Path of the text font altas. */
    optional<std::string>& fontAltas() { return _fontAltas; }
    const optional<std::string>& fontAltas() const { return _fontAltas; }

    /** Path of the icon altas. */
    optional<std::string>& iconAltas() { return _iconAltas; }
    const optional<std::string>& iconAltas() const { return _iconAltas; }

    /** Whether the right / left annotation placement is activated by default */
    optional<bool>& rightLeftPlacementActivated() { return _rightLeftPlacementActivated; }
    const optional<bool>& rightLeftPlacementActivated() const { return _rightLeftPlacementActivated; }

public:

    Config getConfig() const;

protected:
    optional<float>    _minAnimAlpha;
    optional<float>    _minAnimScale;
    optional<float>    _inAnimTime;
    optional<float>    _outAnimTime;
    optional<bool>     _sortByPriority;
    optional<bool>     _sortByDistance;
    optional<bool>     _snapToPixel;
    optional<unsigned> _maxObjects;
    optional<int>      _renderBinNumber;
    optional<bool>     _useScreenGrid;
    optional<int>      _screenGridNbCol;
    optional<int>      _screenGridNbRow;
    optional<std::string>  _defaultFont;
    optional<std::string>  _fontAltas;
    optional<std::string>  _iconAltas;
    optional<bool>      _rightLeftPlacementActivated;

    void fromConfig( const Config& conf );
};

struct OSGEARTH_EXPORT ScreenSpaceLayout
{
    /**
         * Assigns a stateset to the screen-space layout engine.
         * Drawables rendered while this stateset is active will be projected from
         * scene space to 2D screen space with optional decluttering.
         */
    static void activate(osg::StateSet* stateSet); //, int binNum =13);

    /**
         * Deactivates the use of the screen-space layout engine for a stateset.
         */
    static void deactivate(osg::StateSet* stateSet);

    /**
         * Enables or disables decluttering globally.
         */
    static void setDeclutteringEnabled(bool enabled);

    /**
         * Applies the provided options to the layout engine.
         */
    static void setOptions(const ScreenSpaceLayoutOptions& options);

    /**
         * Fetches the current layout options
         */
    static const ScreenSpaceLayoutOptions& getOptions();

public: // advanced

    /**
         * Sets a functor to use to determine render leaf priority for declutter sorting.
         */
    static void setSortFunctor( DeclutterSortFunctor* f );

    /**
         * Clears a custom priority functor that was set using setDeclutterPriorityFunctor,
         * reverting to the default behavior (which is to sort by distance from the camera).
         */
    static void clearSortFunctor();
};

} // namespace osgEarth

#endif //OSGEARTH_SCREEN_SPACE_LAYOUT_H
