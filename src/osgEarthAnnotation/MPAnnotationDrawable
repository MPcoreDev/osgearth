/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield
 *
 * This library is open source and may be redistributed and/or modified under
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * OpenSceneGraph Public License for more details.
 */

#ifndef OSGEARTH_ANNOTATION_DRAWABLE_H
#define OSGEARTH_ANNOTATION_DRAWABLE_H 1

#include <osgEarth/MPScreenSpaceLayoutSG>
#include <osgEarthAnnotation/MPStateSetFontAltas>
#include <osgEarthSymbology/Geometry>
#include <osgEarthSymbology/Style>

namespace osgEarth {
namespace Annotation {

// specific draw array to manage the cluttered case
struct OSGEARTHANNO_EXPORT ScreenSpaceDrawElements
    : public osg::DrawElementsUByte {
  ScreenSpaceDrawElements(GLenum mode = 0) : DrawElementsUByte(mode) {}

  ScreenSpaceDrawElements(const ScreenSpaceDrawElements &array,
                          const osg::CopyOp &copyop = osg::CopyOp::SHALLOW_COPY)
      : DrawElementsUByte(array, copyop), _cluttered(array._cluttered),
        _drawOffset(array._drawOffset), _drawSize(array._drawSize) {}

  void draw(osg::State &state, bool useVertexBufferObjects) const override;

  void setNumEltOffset(int nbElt) {
    _drawOffset = nbElt * _sizeOfElt; /** sizeof(GLubyte) **/
  }

  const int _sizeOfElt{sizeof(vector_type::value_type)};
  bool _cluttered{false};
  int _drawOffset{6 *
                  _sizeOfElt}; // by default, when declutter, the main icon quad
                               // still drawn but not the background box
  int _drawSize{6};            // one quad
};

class OSGEARTHANNO_EXPORT MPAnnotationDrawable : public MPScreenSpaceGeometry {

public:
  typedef std::pair<std::vector<unsigned int>, osg::Vec3> ShiftInfo;

  struct LODAnno {
  public:
    LODAnno(double alt, const std::vector<GLubyte> &pDrawElt)
        : altitudeMax{alt}, drawElts{pDrawElt} {}
    double altitudeMax{DBL_MAX};
    std::vector<GLubyte> drawElts;
    std::vector<ShiftInfo> shiftVec;
  };

  MPAnnotationDrawable(const osgEarth::Symbology::Style &style,
                       const osgDB::Options *readOptions,
                       MPStateSetFontAltas *atlasStateSet);

  /** set the right geometry LOD according to the cam altitude **/
  void setAltitude(double alt);

  /** get wether the annotation has some part displayed or if it is complety
   * hidden **/
  bool isFullyHidden() const { return _d->size() == 0; }

  /** update this geometry to take into account a rotation greater than 90Â° **/
  void setInverted(bool inverted);
  bool isInverted() const { return _inverted; }

  /** make this annotation highlighted or dehighlighted **/
  void setHighlight(bool highlight,
                    optional<bool> declutterActive = optional<bool>());

  /** change main icon color **/
  void setIconColor(const Color &color);

  /** update main icon **/
  void updateIcon(const std::string &icon);

  /** management of the visibility of this annotation **/
  void setVisible(bool visible);
  bool isVisible() const { return _isVisible; }

  /** active the decluttered mode of this annotation **/
  void activeClutteredDrawMode(bool cluttered) override;

  /** change the annotation display layout **/
  virtual void setPlacementLayout(PlacementLayout placementLayout) override;

  /** change the position of this annotation **/
  void updateGeometry(GeoPoint &pos, double geographicCourse = DBL_MAX);
  void updateGeometry(const Symbology::Geometry *geom,
                      double geographicCourse = DBL_MAX);

  /** get the current position **/
  const GeoPoint &getPosition() const { return _position; };

protected:
  virtual ~MPAnnotationDrawable() {}

  void buildGeometry(const osgEarth::Symbology::Style &style);

  float appendIcon(const std::string &urlPath,
                   const osg::Vec4 &color = Color::White, double alt = DBL_MAX,
                   float xMax = FLT_MAX);
  int appendText(const std::string &text, const std::string &font,
                 const osg::Vec4 &color = Color::White, double fontSize = 16.,
                 double alt = DBL_MAX, bool pushDrawAfter = false);
  int appendBox(const osg::BoundingBox &bbox,
                const osg::Vec4 &fillColor = Color::White,
                const osg::Vec4 &strokeColor = osg::Vec4(0., 0., 0., 0.),
                BBoxSymbol::BboxGeom geomType = BBoxSymbol::BboxGeom::GEOM_BOX,
                bool oppose = false, float strokeWidth = 0.f,
                float reverseVideoX = 0.f, float margin = 4.f,
                double alt = DBL_MAX);
  void moveTextPosition(
      int nbVertices, const osg::BoundingBox &refBBox,
      osgEarth::Symbology::TextSymbol::Alignment alignment =
          osgEarth::Symbology::TextSymbol::Alignment::ALIGN_CENTER_CENTER);

  int pushDrawElements(double alt, const std::vector<GLubyte> &pDrawElt,
                       bool pushDrawAfter = false);

  void dirty();

  void mvLeftShiftInfoForText(const std::string &text, unsigned int iVertFirst,
                              unsigned int iVertLast, float offset = 0.f);
  ShiftInfo buildShiftInfo(unsigned int iVertFirst, unsigned int iVertLast,
                           float offset = 0.f) const;

  // the list of level of detail
  std::vector<LODAnno> _LODlist;

  // highlight current state
  bool _isHighlighted{false};

  // false if this annotation must be hidden
  bool _isVisible{true};

  // the current position
  GeoPoint _position;

  // main icon vertices
  std::vector<unsigned int> _mainIconVertices;
  std::vector<unsigned int> _mainIconDrawIndex;

  osg::observer_ptr<osg::Vec3Array> _v{nullptr};
  osg::observer_ptr<osg::Vec4Array> _c{nullptr};
  osg::observer_ptr<osg::Vec2Array> _t{nullptr};
  osg::observer_ptr<osg::Vec4Array> _infoArray{nullptr};
  osg::observer_ptr<osg::Vec4Array> _c2{nullptr};
  osg::observer_ptr<ScreenSpaceDrawElements> _d{nullptr};

  URIContext _context;
  const osgDB::Options *_readOptions{nullptr};
  osg::ref_ptr<MPStateSetFontAltas> _stateSetFontAltas{nullptr};
  double _scale{1.};
  float _bbox_margin{2.};
  float _icon_margin{5.};
  float _multi_text_margin{4.};
  std::string _mainFont;
  Color _mainTextColor{Color::White};
  double _mainFontSize{16.};
  double _altTextFirstLevel{DBL_MAX};
  double _altIconFirstLevel{DBL_MAX};
  double _alt2ndLevel{DBL_MAX};
  osgText::String::Encoding _text_encoding{osgText::String::ENCODING_UNDEFINED};
  double _camAlt{0.};
  int _LOD{-1};
  bool _inverted{false};
  std::vector<unsigned int> _rot_verticesToInvert;
  std::vector<ShiftInfo> _rot_verticesToShift;
  bool _invertLOD{false};
  std::vector<unsigned int> _mvLeft_verticesToInvert;
  std::vector<ShiftInfo> _mvLeft_verticesToShift;
};

} // namespace Annotation
} // namespace osgEarth

#endif
